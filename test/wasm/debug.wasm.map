{"version":3,"sources":["node_modules/asc-linear-rt/lm.ts","~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/index.ts"],"names":[],"mappings":"iOAiOS,AAAW,AAAyC,WACrD,EAA2B,KAAe,KAAa,eAEvD,AAAgB,EAA0B,KAC1C,AAAI,AAAC,AAAC,KAA+B,GAAa,EAAM,MAAU,EAA2B,SACzF,AAAO,KAHX,AAAO,YAMX,sCArJH,AAAW,IACX,EAAgB,IAChB,EAAgB,IAChB,AAA0B,AAAC,AAAC,EAAc,GAAa,GAAW,AAAC,MAAW,KAC9E,AAAoB,IACpB,AAAoB,AAAO,AAAC,AAAC,EAAa,GAAK,KAAU,AAAC,QAAY,KACtE,AAAI,EAAc,KAAe,AAAY,EAAc,KAAe,SAAG,EAC7E,AAAuB,IACvB,EAAW,IAAM,IAAU,IAlD3B,EAAgB,IAChB,EAAe,IACf,EAAe,IACf,EAAe,KAgDf,AAAmB,IACnB,EAAa,AAAC,AAAQ,EAAiB,GAAO,GAAa,WA9B3D,AAAI,GAGJ,AAAoB,IACpB,AAAsB,EAAe,KACrC,AAAoB,EAAgB,KACpC,AAAsB,AAAM,EAAW,AAAC,EAAc,MACtD,EAAQ,EAAa,MACrB,AAAoB,AAAO,AAAC,EAAO,KAAU,AAAC,QAAY,KAC1D,AAAoB,EAAc,KAClC,AAAI,AAAY,IAAe,KAC9B,EAED,AAAY,AAAkB,EAAgB,KAC9C,AAAmB,IACnB,EAAa,AAAC,AAAC,EAAa,GAAgB,GAAM,GAAkB,KACpE,EAAW,AAAuB,EAAgB,KAAgB,OAAe,IAtCjF,EAAgB,IAChB,EAAe,IACf,EAAe,IACf,EAAe,UAkFf,AAAgB,AAAkB,OAClC,AAAwB,IACxB,AAAI,KAAuB,GAAU,GAAe,EAAiB,MACpE,AAAkB,KAElB,AAAkB,AAAQ,EAAiB,YAO5C,AAAO,EAAQ,IAtGf,AAAQ,AAAC,EAAQ,AAAC,EAAK,GAAoB,IAAM,AAAE,AAAC,EAAK,GAAoB,UAuG7E,AAAI,EAAO,SAAe,EAAgB,gBAC1C,AAAI,AAAC,KAAU,GACf,AAA2B,EAAe,2EAC1C,AAAI,AAAC,KACJ,AAAW,IACX,AAAgB,EAAe,IA5C3B,AAAW,AAAyC,WACxD,EAA2B,KAAe,KAAa,eAEvD,AAAI,KAA+B,KAClC,AAAO,MAFR,AAAO,YAKR,KAsCC,AAAI,AAAC,KACJ,GAGF,AAAY,IACZ,AAAI,KAAa,GAAO,KACvB,AAAkB,EAAgB,GAAO,KACzC,AAAsB,EAAW,AAAC,EAAc,GAAc,MAC9D,EAAQ,KACR,EAAe,KACf,AAAI,AAAE,AAAC,EAAc,GAAmB,EAAgB,UACvD,AAAe,IACf,EAAgB,KAAa,GAAO,KACpC,EAAa,IACb,EAAW,IACV,IACA,AAAyC,OAxH5C,EAAgB,IAChB,EAAe,IACf,EAAe,IACf,EAAe,OAwHf,EAAS,IAlHT,AAAW,OACX,AAAW,OACX,AAAI,IAAQ,QACX,EAAY,IACZ,EAAY,IACZ,EAAY,IACZ,EAAY,KAEZ,GA2GD,OACA,EAEA,AAAO,EAAgB","sourceRoot":"./debug","sourcesContent":["\nconst E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\nexport var usageMemorySize: usize = 0;\nexport var objectCount: usize = 0;\n\n// @ts-ignore: decorator\n@unmanaged class LinkedList {\n\tprev: LinkedList;\n\tnext: LinkedList;\n}\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - sizeof<LinkedList>();\n// @ts-ignore: decorator\n@inline const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline const AL_MASK: usize = AL_SIZE - 1;\n// @ts-ignore: decorator\n@unmanaged class Block extends LinkedList {\n\tsize: usize;\n}\n\n// @ts-ignore: decorator\n@inline const BLOCK_SIZE: usize = offsetof<Block>();\n\n// @ts-ignore: decorator\n@inline const MIN_BLOCK_SIZE: usize = offsetof<usize>() + BLOCK_SIZE;\n\nconst freeListPtr: usize = memory.data(sizeof<LinkedList>());\n\n// @ts-ignore: decorator\n@lazy var freelist: LinkedList;\n// @ts-ignore: decorator\n@inline \nfunction alignUp(num: usize): usize {\n\treturn ((num) + ((1 << alignof<usize>()) - 1)) & ~((1 << alignof<usize>()) - 1);\n}\n// @ts-ignore: decorator\n@inline \nfunction insertItem(newItem: LinkedList, preItem: LinkedList, nextItem: LinkedList): void {\n\tnextItem.prev = newItem;\n\tnewItem.next = nextItem;\n\tnewItem.prev = preItem;\n\tpreItem.next = newItem;\n}\n\n// @ts-ignore: decorator\n@inline \nfunction dropItem(item: LinkedList): void {\n\tlet prev = item.prev;\n\tlet next = item.next;\n\tif (prev && next) {\n\t\tprev.next = next;\n\t\tnext.prev = prev;\n\t\titem.prev = changetype<LinkedList>(0);\n\t\titem.next = changetype<LinkedList>(0);\n\t} else {\n\t\tunreachable();\n\t}\n}\n\nfunction growMemory(size: usize): void {\n\tif (ASC_LOW_MEMORY_LIMIT) {\n\t\tunreachable();\n\t}\n\tconst pagesBefore = memory.size();\n\tconst pageBeforePtr = pagesBefore << 16;\n\tconst startPoint = (pageBeforePtr + <i32>BLOCK_SIZE);\n\tconst v128Alignment = <i32>(AL_SIZE - ((startPoint) & <i32>AL_MASK));\n\tsize += startPoint + v128Alignment;\n\tconst pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n\tconst pagesWanted = pagesNeeded - pagesBefore; // double memory\n\tif (memory.grow(pagesWanted) < 0) {\n\t\tunreachable();\n\t}\n\tlet block = changetype<Block>(pageBeforePtr + v128Alignment);\n\tconst pagesAfter = memory.size();\n\tblock.size = ((pagesAfter - pagesBefore) << 16) - <i32>BLOCK_SIZE - v128Alignment;\n\tinsertItem(changetype<LinkedList>(pageBeforePtr + v128Alignment), freelist.prev, freelist);\n}\n\nfunction initialize(): void {\n\tfreelist = changetype<LinkedList>(freeListPtr);\n\tfreelist.next = freelist;\n\tfreelist.prev = freelist;\n\tconst startPoint: usize = ((__heap_base + BLOCK_SIZE + AL_SIZE) & ~AL_MASK) - BLOCK_SIZE;\n\tconst pagesBefore = memory.size();\n\tconst pagesNeeded = <i32>((((startPoint + 1) + 0xffff) & ~0xffff) >>> 16);\n\tif (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n\tlet item: LinkedList = changetype<LinkedList>(startPoint);\n\tinsertItem(item, freelist, freelist);\n\tlet block: Block = changetype<Block>(startPoint);\n\tblock.size = (<usize>(memory.size() << 16)) - BLOCK_SIZE - startPoint;\n\n}\n\n// @ts-ignore: decorator\n@inline \nfunction searchBlockPtr(size: usize): usize {\n\tfor (let item = changetype<LinkedList>(changetype<usize>(freelist.next));\n\t\tchangetype<usize>(item) != freeListPtr && item.next != null;\n\t\titem = item.next) {\n\t\tif (changetype<Block>(item).size > size) {\n\t\t\treturn changetype<usize>(item);\n\t\t}\n\t}\n\treturn 0;\n}\n\nfunction mergeBlock(prevPtr: usize, blockPtr: usize): bool {\n\tlet block = changetype<Block>(blockPtr);\n\tif (prevPtr != freeListPtr && blockPtr != freeListPtr && prevPtr && blockPtr) {\n\t\tlet prevBlock = changetype<Block>(prevPtr);\n\t\tconst prevTailPtr = prevPtr + prevBlock.size + BLOCK_SIZE;\n\t\tif (((blockPtr - prevTailPtr) < BLOCK_SIZE)) {\n\t\t\tconst tailPtr = changetype<usize>(block) + block.size + BLOCK_SIZE;\n\t\t\tprevBlock.size += (tailPtr - prevTailPtr);\n\t\t\tdropItem(changetype<LinkedList>(blockPtr));\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction memoryChangeHook(): void {\n\tconst lastPtr = changetype<usize>(freelist.prev);\n\tconst latestFreeBlock = changetype<Block>(lastPtr);\n\tif (latestFreeBlock.size + lastPtr + BLOCK_SIZE == (memory.size() << 16)) {\n\t\tusageMemorySize = <usize>lastPtr;\n\t} else {\n\t\tusageMemorySize = <usize>(memory.size() << 16);\n\t}\n}\n\n// @ts-ignore: decorator\n@global @unsafe \nexport function __alloc(size: usize): usize {\n\tsize = alignUp(size);\n\tif (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n\tif (!freelist) initialize();\n\tlet foundBlockPtr: usize = searchBlockPtr(size);\n\tif (!foundBlockPtr) { // found ptr\n\t\tgrowMemory(size);\n\t\tfoundBlockPtr = searchBlockPtr(size)\n\t\tif (!foundBlockPtr) {\n\t\t\tunreachable(); // unreachable if cannot get block ptr after grow memory\n\t\t}\n\t}\n\tlet block = changetype<Block>(foundBlockPtr);\n\tif (block.size - size > MIN_BLOCK_SIZE) { // divide linked list\n\t\tlet newBlockPtr = foundBlockPtr + size + BLOCK_SIZE;\n\t\tconst v128Alignment = AL_SIZE - ((newBlockPtr + BLOCK_SIZE) & AL_MASK); // align to 128 for new block\n\t\tsize += v128Alignment;\n\t\tnewBlockPtr += v128Alignment;\n\t\tif (!((newBlockPtr + MIN_BLOCK_SIZE) > (foundBlockPtr + block.size))) { // aligned ptr out of the bound of block\n\t\t\tlet newBlock = changetype<Block>(newBlockPtr);\n\t\t\tnewBlock.size = block.size - size - BLOCK_SIZE;\n\t\t\tblock.size = size;\n\t\t\tinsertItem(changetype<LinkedList>(newBlock),\n\t\t\t\tchangetype<LinkedList>(block),\n\t\t\t\tchangetype<LinkedList>(changetype<usize>(block.next)));\n\t\t}\n\t}\n\tdropItem(block);\n\tobjectCount++;\n\tmemoryChangeHook();\n\n\treturn foundBlockPtr + BLOCK_SIZE;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n\tif (!ptr) unreachable(); // cannot be nullptr\n\tconst freeBlockPtr = ptr - BLOCK_SIZE;\n\tconst block = changetype<Block>(freeBlockPtr);\n\tmemory.fill(ptr, 0, block.size);\n\tlet foundPos: bool = false;\n\tfor (let item = changetype<LinkedList>(changetype<usize>(freelist.next));\n\t\tchangetype<usize>(item) != freeListPtr && item.next != null;\n\t\titem = item.next) {\n\t\tif (changetype<usize>(item) > freeBlockPtr) {\n\t\t\tinsertItem(changetype<LinkedList>(freeBlockPtr), item.prev, item);\n\t\t\tfoundPos = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!foundPos) { // add to tail\n\t\tinsertItem(changetype<LinkedList>(freeBlockPtr), freelist.prev, freelist);\n\t}\n\tlet endPtr = freeListPtr;\n\tfor (let item = changetype<LinkedList>(changetype<usize>(freelist.next));\n\t\tchangetype<usize>(item) != freeListPtr && item.next != null;\n\t\titem = item.next) {\n\t\tconst blockPtr = changetype<usize>(item);\n\t\tconst prevPtr = changetype<usize>(item.prev);\n\t\tif (mergeBlock(prevPtr, blockPtr)) continue;\n\t\tendPtr = blockPtr;\n\t}\n\tlet endBlock = changetype<Block>(endPtr);\n\tmergeBlock(endPtr, changetype<usize>(endBlock.next));\n\t// notify runtime that the end ptr of using block\n\tobjectCount--;\n\tmemoryChangeHook();\n}\n\nfunction moveBlock(block: Block, newSize: usize): usize {\n\tconst ptr = __alloc(newSize);\n\tconst prePtr = changetype<usize>(block) + BLOCK_SIZE;\n\tmemory.copy(ptr, prePtr, block.size);\n\tif (prePtr > __heap_base) __free(prePtr);\n\treturn ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n\treturn moveBlock(changetype<Block>(ptr - BLOCK_SIZE), size);\n}\n\n// @ts-ignore: decorator\n@global\nexport function chkMemAvai(ptr: usize, size: usize): bool {\n    for (let item = changetype<LinkedList>(changetype<usize>(freelist.next));\n        changetype<usize>(item) != freeListPtr && item.next != null;\n        item = item.next) {\n        const freePtr = changetype<usize>(item) + BLOCK_SIZE;\n        if (((changetype<Block>(item).size + freePtr) >= (ptr + size)) && changetype<usize>(item) <= ptr) {\n            return true;\n        }\n    }\n    return false;\n}\n","// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","\nimport { logi, log } from \"./env\";\nimport { chkMemAvai } from \"../node_modules/asc-linear-rt/lm\"\nexport function main(): void {\n    const ptr = 33333;\n    const ptr2 = __alloc(sizeof<i32>() * 2);\n    if (chkMemAvai(33333, 4)) {\n        log(\"memory check free\");\n    }\n    // i32.store(ptr, 42);\n    // i32.store(ptr2, 42);\n    // i32.store(ptr2 + offsetof<i32>(), 42);\n    i32.store(ptr2 + (sizeof<i32>() * 5), 42);\n    // Create a new AVL tree\n    // let tree = new AVLTree();\n\n    // // Insert some values into the tree\n    // tree.insert(10);\n    // tree.insert(5);\n    // tree.insert(15);\n    // tree.insert(3);\n    // tree.insert(7);\n    // tree.insert(13);\n    // tree.insert(17);\n    // log(tree.toString());\n}\n"]}